// DigitalRune Engine - Copyright (C) DigitalRune GmbH
// This file is subject to the terms and conditions defined in
// file 'LICENSE.TXT', which is part of this source code package.

using System;
using DigitalRune.Geometry;
using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Graphics;


namespace DigitalRune.Graphics
{
  partial class MeshHelper
  {
    /// <summary>
    /// Gets the default submesh that represents a sphere using triangles.
    /// (The sphere is centered at the origin. Radius = 1. The sphere is generated by subdividing 
    /// an icosahedron.)
    /// </summary>
    /// <param name="graphicsService">The graphics service.</param>
    /// <returns>
    /// The default submesh of an icosphere. 
    /// This submesh is shared and must not be modified!
    /// </returns>
    /// <remarks>
    /// The returned <see cref="Submesh"/> is a shared instance that must not be modified. 
    /// Use <see cref="CreateIcosphere"/> to create a new <see cref="Submesh"/> instance.
    /// </remarks>
    /// <exception cref="ArgumentNullException">
    /// <paramref name="graphicsService"/> is <see langword="null"/>.
    /// </exception>
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Reliability", "CA2000:Dispose objects before losing scope")]
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
    public static Submesh GetIcosphere(IGraphicsService graphicsService)
    {
      if (graphicsService == null)
        throw new ArgumentNullException("graphicsService");

      const string key = "__Icosphere";
      object submesh;
      if (!graphicsService.Data.TryGetValue(key, out submesh))
      {
        submesh = CreateIcosphere(graphicsService.GraphicsDevice, 3);
        graphicsService.Data[key] = submesh;
      }

      return (Submesh)submesh;
    }


    /// <summary>
    /// Creates a new submesh that represents a sphere using triangles.
    /// (The sphere is centered at the origin. Radius = 1. The sphere is generated by subdividing 
    /// an icosahedron.)
    /// </summary>
    /// <param name="graphicsDevice">The graphics device.</param>
    /// <param name="numberOfSubdivisions">
    /// The number of subdivisions [0, 5]. (See remarks of 
    /// <see cref="GeometryHelper.CreateIcosphere"/>.) 
    /// This parameter controls the detail of the mesh.</param>
    /// <returns>A new <see cref="Submesh"/> that represents an icosphere.</returns>
    /// <remarks>
    /// If the returned <see cref="Submesh"/> is not going to be modified, then it is better
    /// to call <see cref="GetIcosphere"/> to retrieve a shared <see cref="Submesh"/> instance.
    /// </remarks>
    /// <exception cref="ArgumentNullException">
    /// <paramref name="graphicsDevice"/> is <see langword="null"/>.
    /// </exception>
    /// <exception cref="ArgumentOutOfRangeException">
    /// <paramref name="numberOfSubdivisions"/> is less than 1.
    /// </exception>
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Reliability", "CA2000:Dispose objects before losing scope")]
    public static Submesh CreateIcosphere(GraphicsDevice graphicsDevice, int numberOfSubdivisions)
    {
      if (graphicsDevice == null)
        throw new ArgumentNullException("graphicsDevice");
      if (numberOfSubdivisions < 1)
        throw new ArgumentOutOfRangeException("numberOfSubdivisions", "numberOfSegments must be greater than 0");

      var submesh = new Submesh
      {
        PrimitiveType = PrimitiveType.TriangleList,
      };

      var mesh = GeometryHelper.CreateIcosphere(numberOfSubdivisions, false);
      int numberOfVertices = mesh.Vertices.Count;
      var vertexData = new VertexPositionNormal[numberOfVertices];
      for (int i = 0; i < numberOfVertices; i++)
      {
        Vector3 v = (Vector3)mesh.Vertices[i];
        vertexData[i] = new VertexPositionNormal(v, v);
      }

      submesh.VertexBuffer = new VertexBuffer(
        graphicsDevice,
        VertexPositionNormal.VertexDeclaration,
        vertexData.Length,
        BufferUsage.None);
      submesh.VertexBuffer.SetData(vertexData);

      submesh.VertexCount = submesh.VertexBuffer.VertexCount;

      int numberOfTriangles = mesh.NumberOfTriangles;
      int numberOfIndices = mesh.Indices.Count;
      var indexData = new ushort[numberOfIndices];
      for (int i = 0; i < numberOfTriangles; i++)
      {
        // Flip vertex order. (DigitalRune Geometry uses CCW, XNA uses CW.)
        indexData[3* i + 0] = (ushort)mesh.Indices[3 * i + 0];
        indexData[3 * i + 2] = (ushort)mesh.Indices[3 * i + 1];
        indexData[3 * i + 1] = (ushort)mesh.Indices[3 * i + 2];
      }

      submesh.IndexBuffer = new IndexBuffer(
        graphicsDevice,
        IndexElementSize.SixteenBits,
        indexData.Length,
        BufferUsage.None);
      submesh.IndexBuffer.SetData(indexData);

      submesh.PrimitiveCount = indexData.Length / 3;

      return submesh;
    }
  }
}
